# Resultados {-}

```{r}
# Carga del modelo svar-sv
fit <- readRDS(here::here("Datos", "Finales", "modelo.rds"))

# Función para generar los gráficos de parámetros y varianzas
matplot2 <- function(...) matplot(..., type = "l", lty = 1, lwd = 2, bty = "n", ylab = "")
stat.helper <- function(z) c(mean(z), quantile(z, c(0.16, 0.84)))[c(2, 1, 3)]
gp <- seq(1985, 2020, 5) # marks for vertical lines
# colors, taken from http://www.cookbook-r.com
cols <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
cols1 <- cols[c(2, 4, 2)]
make_plot <- function(.fit = fit, .type = "vcv", .var = 1, .title = "") {
    gp <- seq(1990, 2020, 5) # marks for vertical lines
    if(.type == "vcv") {
        # SD of unemployment residual
        # Get posterior draws
        sd_inf <- parameter.draws(.fit, type = .type, row = .var, col = .var)
        x1     <- t(apply(sqrt(sd_inf), 2, stat.helper))    
    } else if (grepl(x = .type, pattern = "lag")) {
        beta <- parameter.draws(fit, type = .type, row = .var, col = .var)
        x1   <- t(apply(beta, 2, stat.helper))    
    } else {
        beta_0 <- parameter.draws(fit, type = .type, row = .var, col = .var)
        x1     <- t(apply(beta_0, 2, stat.helper))       
    }
    xax <- seq(1990, 2018, length.out = NROW(x1)) # x axis
    # Plot
    if(.type == "vcv") {
        var <- sd.residuals.ols[.var]
    } else {
        var <- NULL
    }
    matplot2(x = xax, y = x1, ylim = c(min(x1), max(x1)), col = cols1, main = .title , xlab = "Fecha")
    abline(h = seq(min(x1), max(x1), length.out = 10), v = gp, lty = 4, lwd = 0.3)
    if(.type == "vcv") {
        abline(h = var, col = cols[1], lwd = 1.4, lty = 5)
    }
}

# Función para generar los IRF
plot_irf <- function(.fit = fit, impulse, response, scenario = 2) {
    ira <- impulse.responses(fit, impulse.variable = impulse, response.variable = response, scenario = scenario)
    # OLS impulse responses for comparison
    ira.ols <- irf(fit.ols, n.ahead = 20)[[impulse]][[response]][-1, 1]
    # Add to plot
    lines(x = 1:20, y = ira.ols, lwd = 1, lty = 5, col = "red")
}

# carga del modelo var
library(vars)
fit.ols <- readRDS(here::here("Datos", "Finales", "modelo-var-comun.rds"))
sd.residuals.ols <- apply(residuals(fit.ols), 2, sd)
```

Este capítulo presenta los resultados principales del trabajo. Primero gráficamos la curva de Beveridge entre 1981 y 2018,
posteriormente analizamos las series utilizados y sus propiedades estadísticas, tales como raíces unitarias, raíces estacionales, cointegración, etc..
Finalmente estimamos un SVAR y observamos las FIR y nos damos cuenta que los efectos provienen de la variabilidad en la varianza.

## Curva de Beveridge

```{r beveridge-curve, fig.cap="Curva de Beveridge 1981-2018", fig.subcap=c('Curva de Beveridge trimestral', 'Curva de Beveridge anual'), out.width='.49\\linewidth', fig.asp=1, fig.ncol = 2, fig.fullwidth = TRUE, fig.height=7, fig.width=7}

xaxis = list(title = "Tasa de desempleo")
yaxis = list(title = "Tasa de vacantes")
t <- list(
    family = "sans serif",
    size = 8,
    color = toRGB("grey50"))

dt[, plot_ly(x = td, y = ind_vac, type = "scatter", mode = "lines", color = decada) %>% 
       layout(showlegend = FALSE,
              axis = axis,
              yaxis = yaxis)
   ]
plot_ly(dt[, .(td = mean(td), ind_vac = mean(ind_vac), decada = min(decada)), keyby = .(ano)], 
        x = ~td, y = ~ind_vac, text =~ ano, color =~ decada) %>%
    add_trace(mode = "lines+markers", type = "scatter") %>% 
    add_text(textfont = t, textposition = "top right") %>%
    layout(showlegend = FALSE,
              axis = axis,
              yaxis = yaxis)
```

El primer hallazo del trabajo se observa en la figura \@ref(fig:beveridge-curve)a, con una relación negativa y convexa entre vacantes y desempleo en linea con la teoría económica para mercados laborales de economías de mercado. El color azul denota la década de 1980, rosado años 90, verde los 2000 y finalmente naranja 2010 a 2020. 

El segundo resultado, es que se existen claros movimientos a lo largo de la curva (por décadas) y traslados de la misma (entre décadas). 
En la figura \@ref(fig:beveridge-curve)b observamos los promedio anuales del índice de vacantes y tasa de desempleo, si analizamos por década, podemos identificar 4 fases, donde los años 90 trasladan la curva hacia un nuevo estado con mayor desempleo ante igual cantidad de vacantes, el mismo se estabiliza en los 2000 y vuelve a cambiar de 2010 en adelante entrando en una nueva fase con menor desempleo ante misma cantidad de vacantes. Si nos limitamos a un lustro, podemos ver que a partir de 2005 parece haber un cambio en el mercado laboral, el cual se mantiene y vuelve a cambiar en 2010. Lo que se observa claramente en la curva, es que el mercado laboral debió transitar un cambio profundamente negativo en la década del 90 y que en los últimos 15 ha sucedido lo mismo pero en sentido inverso, es decir, estaríamos en un mercado laboral que soporta una tasa de desempleo mayor lo que podría indicar una mayor eficiencia del mismo.


```{r td-vac-pib, fig.cap="Desempleo-Vacantes", fig.subcap=c('asa', 'bba'), out.width='.49\\linewidth', fig.ncol = 2}
plotly::subplot(
dt[, .(td = mean(td), ind_vac = mean(ind_vac), pib = mean(pib), decada = min(decada)), keyby = .(ano)
   ][, plot_ly(x = ind_vac, y = pib, type = "scatter", mode = "markers+lines", color = decada, text = ~ ano) %>% 
         add_text(textfont = t, textposition = "top right") %>%
         layout(showlegend = FALSE,
                xaxis = list(title = "Índice de vacantes"),
                yaxis = list(title = "IVF PIB"))],
dt[, .(td = mean(td), ind_vac = mean(ind_vac), pib = mean(pib), decada = min(decada)), keyby = .(ano)
   ][, plot_ly(x = td, y = pib, type = "scatter", mode = "markers+lines", color = decada, text =~ ano) %>% 
         add_text(textfont = t, textposition = "top right") %>%
         layout(showlegend = FALSE,
                xaxis = list(title = "Tasa de desempleo"),
                yaxis = list(title = "IVF PIB"))],
nrows = 2
)
```

En la figura PIB-VACANTES podemos observar la relación entre vacantes y PIB. Es interesante notar la diferencia en la década de 2010, la notoria caída en las vacantes laborales no se ve acompaña por una caída del PBI, como puede observarse en los años 80 y 2000. La tasa de variación en la cual caen las vacantes laborales entre 2011 y 2018, es prácticamente la misma entre 1998-2002 y  1981 y 1983, sin embargo el nivel no cae en ningún momento por lo que no se observa el movimiento de U típico de 80-82 y 98-2002.

En la figura PIB-DESEMPLEO, observamos el mismo comportamiento de la CB en los años 90, una transición hacia lo que podríamos catalogar como un nuevo estado, una década de crecimiento con alto desempleo, hacia otra con crecimiento y caída del desempleo, los años 2000. Además, los 80 y 2000 vuelven a compartir la forma de U, solo que esta vez es en sentido contrario. La década de 2010, muestra a diferencia del gráfico anterior un comportamiento similar a los 90, se observa crecimiento económico con crecimiento del desempleo, aunque el nivel de actividad no cae en ningún momento.

## Caracterización de las series {-}
<!-- Acá hay que realizar todo un análisis exploratorio, raíces unitarias, raíces estacionales, cointegración de desempleo y vacantes. -->
```{r include=FALSE}
# Series trimestrales
# readRDS(here::here("Datos", "Finales", "serie_trimestral_ga_13-19.rds"))
ga_ts <- ts(dt[, av_umcg], start = c(1980, 1), frequency = 4)
um_ts <- ts(dt[!is.na(av_urr_mol), av_urr_mol], start = c(1980, 1), frequency = 4)
ct_ts <- ts(dt[!is.na(av_ct_s_dup), av_ct_s_dup], start = c(2003, 3), frequency = 4)
bj_ts <- ts(dt[av_bj_s_dup > 0, av_bj_s_dup], start = c(2007, 2), frequency = 4)
final <- ts(dt[, av_final], start = c(1980, 1), frequency = 4)
final_tc <- ts(dt[, av_final_tc], start = c(1980, 1), frequency = 4)
pib   <- ts(dt[!is.na(pib), pib], start = c(1981, 1), frequency = 4) 
ind_vac   <- ts(dt[!is.na(ind_vac), ind_vac], start = c(1980, 1), frequency = 4)
desempleo <- ts(dt[!is.na(td), td], start = c(1981, 1), frequency = 4)
pea <- ts(dt[!is.na(pea), pea], start = c(1980, 1), frequency = 4)

for(serie in c("ga_ts", "ct_ts", "bj_ts", "um_ts", "final", "final_tc", "pib", "ind_vac", "desempleo", "pea")) {
    for(test in c("adf", "kpss", "pp")) {
        print(c(serie, test, forecast::ndiffs(get(serie), alpha = 0.05, test = test, max.d = 2, type = "level")))
    }
}

for(serie in c("ga_ts", "ct_ts", "bj_ts", "um_ts", "final", "final_tc", "pib", "ind_vac", "desempleo", "pea")) {
    for(test in c("hegy", "ocsb", "ch")) {
        print(c(serie, test, forecast::nsdiffs(get(serie), alpha = 0.05, test = test)))
    }
}

# Series mensuales
bj_ct_mensual <- readRDS(here::here("Datos", "Finales", "serie_mensual_bj_ct.rds"))
gallito_mensual <- readRDS(here::here("Datos", "Finales", "serie_mensual_ga_13-19.rds"))

ct_ts <- ts(bj_ct_mensual[, av_ct_s_dup], start = c(2003, 5), frequency = 12)
bj_ts <- ts(bj_ct_mensual[av_bj_s_dup > 0, av_bj_s_dup], start = c(2007, 6), frequency = 12)
ga_ts <- ts(gallito_mensual[, avisos_s_dup], start = c(2013, 7), frequency = 12)
# ceres_ts <- ts(dt[!is.na(av_ceres), av_ceres], start = c(1998, 4), frequency = 12)

for(serie in c("ga_ts", "ct_ts", "bj_ts")) {
    for(test in c("adf", "kpss", "pp")) {
        print(c(serie, test, forecast::ndiffs(get(serie), alpha = 0.05, test = test, max.d = 2, type = "level")))
    }
}

for(serie in c("ga_ts", "ct_ts", "bj_ts")) {
    for(test in c("hegy", "ocsb", "ch")) {
        print(c(serie, test, forecast::nsdiffs(get(serie), alpha = 0.05, test = test)))
    }
}

```

Serie               | Test regular    | Diferencias |  Test estacional    | Diferencias
--------------------|-----------------|-------------|---------------------|-------------
gallito 80-19       | ADF, KPSS, PP   |       1     | HEGY, OCSB, CH      |    0
urr_mol 80-01       | ADF, KPSS, PP   |       1     | HEGY, OCSB, CH      | 1, 0, 0
computrabajo 03-19  | ADF, KPSS, PP   |       1     | HEGY, OCSB, CH      | 1, 0, 0
buscojobs 07-19     | ADF, KPSS, PP   |       0     | HEGY, OCSB, CH      | 1, 0, 0
serie_final         | ADF, KPSS, PP   |       1     | HEGY, OCSB, CH      |    0
pea                 | ADF, KPSS, PP   |       1     | HEGY, OCSB, CH      |    0
tasa desempleo      | ADF, KPSS, PP   |       1     | HEGY, OCSB, CH      |    0
PIB                 | ADF, KPSS, PP   |       1     | HEGY, OCSB, CH      |    0
índice de vacantes  | ADF, KPSS, PP   |       1     | HEGY, OCSB, CH      |    0

Table: Test de raíces unitarias ADF, KPSS y PP. Test de raíces unitarias estacionales HEGY, OCSB y CH. Series con frecuencia trimestral.

El cuadro XX columna 2 muestra los resultados de la aplicación de los test Dickey Fuller Aumentado (ADF), Kwiatkowski–Phillips–Schmidt–Shin (KPSS) y Phillips-Perron (PP). El test ADF y PP usan la hipótesis nula que la serie tiene una raíz unitaria versus una hipótesis alternativa de una raíz estacionaria (CITAR EL PAPER). En el test KPSS la hipótesis nula es que la serie tiene una raíz estacionaria contra una hipótesis alternativa de raíz unitaria (CITAR EL PAPER). La columna diferencias refiere a la cantidad de diferencias regulares necesarias para que la realización del proceso estócastico se vuelva estacionario. El resultado es que la serie de vacantes es un proceso integrado I(1), al igual que dos de las tres series que la componen, la serie de avisos del gallito (años 80 a 2019) y la serie de computrabajo (2003 a 2019), mientras buscojobs resulta ser I(0). Tanto el PIB como la tasa de desempleo, resultan procesos integrados de orden uno. Si bien existe evidencia que los test KPSS y ADF (CITAR) pueden dar conclusiones contrapuestas, en todos los casos los resultados con coincidentes.

La columna test estacional, muestra los test de raíz unitaria estacional realizados. El test de Hylleberg, Engle, Granger & Yoo (HEGY) pone aprueba la hipótesis nula de que las raíces del polinomio autoregresivo caen dentro del circulo unitario versus la alternativa que caen fuera. El test de Osborn-Chui-Smith-Birchenhall (OCSB) utiliza la hipótesis nula de raíz unitaria estacional versus la alternativa de estacionariedad. Mientras el test Canova-Hansen (CH) plantea la hipótesis nula de la no existencia de raíz unitaria en las frecuencias estacionales versus la alternativa de raíz unitaria en una frecuencia estacional o en un conjunto de frecuencias estacionales (CITAR). La última columna de la tabla refiere a la cantidad de diferencias estacionales necesarias para que el proceso se vuelva estacionario, los tres test llevan a las mismas conclusiones tanto para el PIB, tasa de desempleo e índice de vacantes, no son necesarias diferencias estacionales. Sin embargo, en el caso de la serie de buscojobs y computrabajo los resultados difieren, para ambas el test HEGY plantea la existencia de raíz unitaria en frecuencias estacional mientras los test OCSB y CH la descartan.

Por último el cuadro XXX realiza lo mismos test pero con un subconjunto de series de frecuencia mensual. Las series de gallito y computrabajo, muestran resultados sin ambiguedades, son procesos I(1) mientras buscojobs es un proceso I(1) para KPSS pero I(0) para ADF y PP, notar que cuando la serie es trimestralizada los tres test coinciden. Los test de raíz unitaria estacional plantean que no es necesario realizar diferencias estacionales tanto para computrabajo como buscojobs, por el contrario, la serie de gallito según HEGY y CH necesita una diferencia estacional, no así para OCSB. Dicho resultado difiere cuando la serie es trimestralizada, en donde los tres test coinciden en la no existencia de raíz unitaria estacional.


Serie               | Test regular    | Diferencias |   Test estacional   | Diferencias
--------------------|-----------------|-------------|---------------------|-------------
gallito 13-19       | ADF, KPSS, PP   |       1     | HEGY, OCSB, CH      | 1, 0, 1
computrabajo 03-19  | ADF, KPSS, PP   |       1     | HEGY, OCSB, CH      | 0, 0, 0
buscojobs 07-19     | ADF, KPSS, PP   |  0, 1, 0    | HEGY, OCSB, CH      | 0, 0, 0

Table: Test de raíces unitarias ADF, KPSS y PP. Test de raíces unitarias estacionales HEGY, OCSB y CH. Series con frecuencia mensual.

Dada la correlación negativa entre vacantes y desempleo, y el orden de integración igual a 1 es posible esperar que exista una relación de largo plazo entre las series, por lo cual siguiendo a PHILLIPS-OULARIES quienes construyen sobre ENGLEA-GRANGER se lleva a cabo el test de cointegración de Phillips-Ouliaris entre el índice de vacantes y la tasa de desempleo. Dado que el test no es invariante a la formulación de la ecuación de regresión, se realizan dos test utilizando como variable dependiente al índice de vacantes y luego la tasa de desempleo. En ambos casos, no se rechaza la hipótesis nula de no cointegración al 10\%. EL TEST PZ NO TIENE ESE PROBLEMA?? REVISAR
Sin embargo, una vez que se toman logaritmos y se diferencian las series, se rechaza la hipótesis nula de no cointegración al 1\% indicando que las tasas de crecimiento del índice de vacantes laborales y la tasa de desempleo están cointegradas. El resultado se mantiene para la aceleración de las series. Por lo tanto, tanto la velocidad como la aceleración de las vacantes laborales y la tasa de desemeplo muestran una relación estable en el largo plazo,

Se realiza el mismo procedimiento pero esta vez testeando la hipotesis nula de no cointegración entre pib y vacantes, posteriormente pib y desempleo. En ambos casos no se rechaza la hipótesis nula de no cointegración al 10\%. Sin embargo, realizamos el mismo procedimiento con la tasa de crecimiento del pib y vacantes, luego con la tasa de crecimiento del pib y tasa de desempleo. En ambos se rechaza la hipótesis nula de no cointegración al 1\%, el procedimiento devuelve el mismo resultado si se usa la tasa de variación de vacantes o desempleo.

Finalmente siguiendo a JOHANSEN CITAR, se plantean los test de traza y valor propio\footnote{No tiene sentido plantearlo para el caso de dos variables, porque al realizar el test ADF o PO se esta imponiendo un vector de cointegración por lo cual toda la incertidumbre asociada con la estimación del vector de cointegración desaparece. Por el contrario, cuando se utiliza el esquema de Johansen, se estima el vector de cointegración por lo cual la incertidumbre asociada a la estimación se incorpora en el test. En nuestro caso, tiene sentido plantear que el vector existe desde la teoría. Como resultado, el test tiene mas poder, es decir, mayor probabilidad de rechazar la hipótesis nula cuando la hipótesis alternativa es verdadera versus el test de Johansen.} para las series del pib, tasa de desempleo e índice de vacantes, el resultado es que no se rechaza la hipótesis nula de no cointegración al 10\%. Sin embargo, si se utiliza la tasa de crecimiento del pib, se rechaza la hipótesis nula de no cointegración al 1%, y no se rechaza que exista 1 relación de cointegración. Finalmente, si se utilizan solamente las tasas de crecimiento de las variables, no se rechaza la existencia de 3 relaciones de cointegración. Dichos resultados son robustos frente a la especificación de los vectores de cointegración con tendencia, constante o ninguna. Es decir, existe una relación estable de largo plazo entre las tasas de crecimiento del PIB, índice de vacantes y tasa de desempleo.

- Análisis de la estacionalidad
- Serie en tendencia-ciclo
- Quiebres estructurales, usando paquete strucchange::
¿Qué más?



## Quiebres estructurales
<!-- Test de quiebres estructurales -->
<!-- 1- Test de Chow -->
<!-- 2. Todos los test posibles usando structchange -->

```{r}
# Test de Chow
```

```{r}
# Test Cusum?
```

```{r}

```


## SVAR-SV

### Parámetros y varianza

Para poder analizar q

\newpage

```{r SV, fig.cap="Varianzas", fig.align="center", fig.height=8, fig.width=6}
# Análisis de la varianza de los parámetros
par(mfrow = c(3, 1))

make_plot(.fit = fit, .type = "vcv", .var = 1, .title = "pib")
make_plot(.fit = fit, .type = "vcv", .var = 2, .title = "vacantes")
make_plot(.fit = fit, .type = "vcv", .var = 3, .title = "desempleo")
```
\newpage

### FIR

```{r svar-parámetros, fig.cap="Parámetros", fig.align="center", out.width='1\\linewidth'}
par(mfrow = c(3, 2))
for(i in c("intercept", "lag1")) {
    for(j in 1:3) {
        make_plot(.fit = fit, .type = i, .var = j)
    }
}
```


```{r FIR, fig.cap="FIR", fig.subcap=c('one plot', 'the other one'), out.width='.49\\linewidth', fig.asp=1, fig.ncol = 2}
# par(mfrow = c(1,2))
plot_irf(impulse = 1, response = 2)
plot_irf(impulse = 1, response = 3)
```


